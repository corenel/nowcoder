

# 网易2018年笔试题

## 选择题

1. 数字图像颜色空间中，常被彩色显像管采用的是哪一种：
   - [x] RGB
   - [ ] YUV
   - [ ] HIS
   - [ ] CMYK
2. 如下边缘检测算子中，时间复杂度最高的是：
   - [ ] Sobel算子
   - [ ] Roberts算子
   - [ ] Prewitt算子
   - [x] Canny算子
3. 大津法（OSTU算法）阈值分割中，阈值自动选择的思路是：
   - [ ] 由直方图灰度分布选择阈值
   - [ ] 双峰法选择阈值
   - [x]    最大化类间方差法选择阈值
   - [ ]    最大最小灰度值二分迭代逼近法选择阈值 
4. 某地区每个人的年收入是右偏的，均值为5000元，标准差为1200元。随机抽取900人并记录他们的年收入，则样本均值的分布为()
   - [x] 近似正态分布，均值为5000元，标准差为40元
   - [ ] 近似正态分布，均值为5000元，标准差为1200元
   - [ ] 右偏分布，均值为5000，标准差为40
   - [ ] 左偏分布，均值为5000元，标准差为1200元

5. 函数y=x^x,(x＞0)的极小值点是______
   - [ ] $1​$
   - [ ] $\sqrt{2}$
   - [ ] $\sqrt{2}^\sqrt{2}​$
   - [x] $(1/e)^{(1/e)}$

6. 随机变量X和Y的Pearson相关系数ρ取得最大值的充要条件是______
   - [ ] X和Y独立
   - [ ] X和Y不相关
   - [x] X和Y正相关
   - [ ] X等于Y

7. 下列关于核函数的表述正确的是______
   - [ ] 核函数即特征的映射关系。
   - [ ] 多项式核函数只是将原始特征映射，并没有升维
   - [x] 高斯核函数将特征映射到无穷维
   - [ ] 使用线性核函数的SVM是非线性分类器

8. 下列哪项不是SVM的优势____
   - [ ] 可以和核函数结合
   - [ ] 通过调参可以往往可以得到很好的分类效果
   - [x] 训练速度快
   - [ ] 泛化能力好

9. 阅读C++语言代码输出（）A

    ```c++
    int main()
    {
        int arr[]={1,2,3,4,5,6,7};
        int *p=arr;
        (p++)+=89;
        printf("%d,%d\n",p,*(++p));
        return 0;
    }
    ```

   - [x] 3 3
   - [ ] 2 2
   - [ ] 2 3
   - [ ] 3 2

10. 阅读c++代码输出（）

    ```c++
    
    class base1{
        private: int a,b;
        public:
        base1 ( int i ) : b(i+1),a(b){}
        base1():b(0),a(b){}
        int get_a(){return a;}
        int get_b(){return b;}
    };
    int main()
    {
        base1 obj1(11);
        cout<<obj1.get_a()<<endl<<obj1.get_b()<<endl;
        return 0;
    }
    ```

    - [ ] 12 12
    - [x] 随机数 12
    - [ ] 随机数 随机数
    - [ ] 12 随机数



11. 想实现用装饰器来计时，空白处应填的代码是？D
    ```python
    # -*- coding: utf-8 -*-
    import time, functools
    def metric(fn):
        # 空白处
    ​    def wrapper(*args, **kw):
    ​        startTime = time.time()
    ​        tmp = fn(*args, **kw)
    ​        endTime = time.time()
    ​        print('%s executed in %s s' % (fn.__name__, endTime - startTime ))
    ​        return tmp
    ​    return wrapper
    ```

    - [ ] 无需填写
    - [ ] `@functools`
    - [ ] `@time(fn)`
    - [x] `@functools.wraps(fn)`



12. python是用C语言写成的，根据名字空间特性，以下代码经过python编译器编译后，一共得到（）个PyCodeObject对象。
    ```python
    class A:
        pass
    def Fun():
        pass
    a = A()
    Fun()
    ```

    - [ ] `= A()<br>Fun()`
    - [ ] 1
    - [x] 2
    - [ ] 3
    - [ ] 4



13. 用1*3的瓷砖密铺3*20的地板有几种方式？
    - [x] 1278
    - [ ] 872
    - [ ] 595
    - [ ] 406



14. 已知有4个矩阵分别大小为M1(5*3) M2(3*4) M3(4*2) M4(2*7) 下面组合计算所需要的乘法次数最优的为？
    - [ ] (M1(M2(M3M4)))
    - [ ] (M1((M2M3)M4))
    - [ ] ((M1M2)(M3M4))
    - [x] ((M1(M2M3))M4)
    - [ ] (((M1M2)M3)M4)



15. 一个完全二叉树节点数为200，则其叶子结点个数为？
    - [ ] 98
    - [ ] 99
    - [x] 100
    - [ ] 101



16. 字符串zmnzizi用哈夫曼编码来编码，则共有多少位？
    - [ ] 14
    - [x] 13
    - [ ] 12
    - [ ] 11

> 对应zmnzizi的哈夫曼编码为0 100 101 0 11 0 11，共13位



17. 已知中序遍历的序列为abcdef，高度最小的不可能的二叉树的前序遍历是
    - [ ] dbacfe
    - [ ] dbacef
    - [ ] cbaedf
    - [x] cabefd



18. 以下算法中未用到贪心算法思想的是？
    - [ ] 迪杰斯特拉(Dijkstra)
    - [ ] 库鲁斯卡尔(Kruskal)
    - [ ] 普里姆算法(Prim)
    - [x] KMP

> KMP求字符串匹配，应该是属于时空权衡
>
> Prim、Kruskal求最小生成树，Dijkstra求最短路径，哈夫曼树均使用贪婪技术
>



19. 对于线性表（ 13,25,22,35,54,57,63）进行散列存储时，若选用 H （ K ） =K %7作为散列函数，则散列地址为 1 的元素有（ ）个？
    - [ ] 0
    - [ ] 1
    - [x] 2
    - [ ] 3



20. 下列选项中，不可能是快速排序第2趟排序结果的是 （）
    - [ ] 4 14 10 12 8 6 18
    - [ ] 4 6 10 8 12 14 18
    - [x] 6 4 10 8 14 12 18
    - [ ] 8 4 6 10 12 14 18

> 快速排序，选取一个基准数，两个指针i,j分别从左到右找大于它的，从右往左找小于它的，先j开始。一趟排序下来，满足小于该基准数的在左边，大于基准数的在右边。
>
> 第一趟排序找到一个数，小于它的在左，大于它的在右。
>
> 第二趟分别看上一趟找到的基准数的左边和右边，是否也呈存在一个一个基准数，使得左边的数小于它右边的数大于它。
>
> 例如选项A：原序列 18 14 10 12 8 6 4，第一趟基准数18，快速排序结果4 14 10 12 8 6 18，第二趟看18的左边，基准数为4，排序结果4 14 10 12 8 6 18
>
> 选项B 同A：原序列18 6 10 8 12 14 4
>
> 选项D ：原序列18 4 6 8 12 14 10
>

## 编程题

### 矩形重叠
时间限制：1秒

空间限制：32768K

平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。

如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。

请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。


输入描述:
输入包括五行。
第一行包括一个整数n(2 <= n <= 50), 表示矩形的个数。
第二行包括n个整数x1[i](-10^9 <= x1[i] <= 10^9),表示左下角的横坐标。
第三行包括n个整数y1[i](-10^9 <= y1[i] <= 10^9),表示左下角的纵坐标。
第四行包括n个整数x2[i](-10^9 <= x2[i] <= 10^9),表示右上角的横坐标。
第五行包括n个整数y2[i](-10^9 <= y2[i] <= 10^9),表示右上角的纵坐标。

输出描述:
输出一个正整数, 表示最多的地方有多少个矩形相互重叠,如果矩形都不互相重叠,输出1。

输入例子1:
```
2
0 90
0 90
100 200
100 200
```
输出例子1:
```
2
```

```python

import sys
lines = sys.stdin.readlines()
n = int(lines[0])
x1 = list(map(int,lines[1].split()))
y1 = list(map(int,lines[2].split()))
x2 = list(map(int,lines[3].split()))
y2 = list(map(int,lines[4].split()))
# 遍历所有点的组合（包含了矩形所有角以及交点），看一下有多少矩形包含它
res = 1
for x in x1+x2:
    for y in y1+y2:
        cnt = 0
        for i in range(n):
            if x > x1[i] and y > y1[i] and x <= x2[i] and y <= y2[i]:
                cnt += 1
        res = max(res,cnt)
print(res)
```



### 牛牛的闹钟
时间限制：1秒

空间限制：32768K

牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床

输入描述:
每个输入包含一个测试用例。
每个测试用例的第一行包含一个正整数，表示闹钟的数量N(N<=100)。
接下来的N行每行包含两个整数，表示这个闹钟响起的时间为Hi(0<=A<24)时Mi(0<=B<60)分。
接下来的一行包含一个整数，表示从起床算起他需要X(0<=X<=100)分钟到达教室。
接下来的一行包含两个整数，表示上课时间为A(0<=A<24)时B(0<=B<60)分。
数据保证至少有一个闹钟可以让牛牛及时到达教室。

输出描述:
输出两个整数表示牛牛最晚起床时间。

输入例子1:

```
3 
5 0 
6 0 
7 0 
59 
6 59
```

输出例子1:

```
6 0
```

解答：

```python

n = int(input())

def to_minute(h, m):
    return h*60+m

alarm = [list(map(int, input().split())) for i in range(n)]

t = int(input())
t_class = list(map(int, input().split()))

res = [0, 0]
for i in alarm:
    if to_minute(*i)+t <= to_minute(*t_class) and to_minute(*i) > to_minute(*res):
        res = i
         
print(*res)
```

### 牛牛的背包问题
时间限制：1秒

空间限制：32768K

牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。
牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。
牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。

输入描述:
输入包括两行
第一行为两个正整数n和w(1 <= n <= 30, 1 <= w <= 2 * 10^9),表示零食的数量和背包的容量。
第二行n个正整数v[i](0 <= v[i] <= 10^9),表示每袋零食的体积。

输出描述:
输出一个正整数, 表示牛牛一共有多少种零食放法。

输入例子1:
```
3 10
1 2 4
```

输出例子1:
```
8
```

例子说明1:
三种零食总体积小于10,于是每种零食有放入和不放入两种情况，一共有$2*2*2 = 8$种情况。

```python
line = input()
n = int(line.split(' ')[0])
w = int(line.split(' ')[1])
line = input()
v = []
for i in range(n):
    v.append(int(line.split(' ')[i]))

def brute_force(remain_items, available_weight):
    if len(remain_items) == 0:
        return 1
    elif available_weight == 0:
        return 1
    else:
        item = remain_items[0]
        if item < available_weight:
            return brute_force(remain_items[1:], available_weight-item) + brute_force(remain_items[1:], available_weight)
        else:
            return brute_force(remain_items[1:], available_weight)

def brute_force2(remain_items, available_weight, item_sum):
    if len(remain_items) == 0:
        return 1
    elif available_weight == 0:
        return 1
    elif item_sum < available_weight:
        return 2**len(remain_items)
    else:
        item = remain_items[0]
        if item < available_weight:
            if item_sum - item < available_weight:
                return 2**len(remain_items[1:])
            else:
                return brute_force2(remain_items[1:], available_weight-item, item_sum-item) \
                       + brute_force2(remain_items[1:], available_weight, item_sum)
        else:
            return 1

print(brute_force2(sorted(v), w, sum(v)))
```



## 问答题（任选2道作答）

### 识别图像中商品logo

假设有一个识别图像中商品logo的业务需求，期望输入一张图片判断其中是否带有目标logo，我们计划借助深度学习分类或检测方法来解决该业务问题。

（1）作为算法同学，请问你想要知道哪些更加详细的业务信息？

（2）实际情况下我们能够收集到的带logo图片数据非常少，请问有哪些处理方式可以增加训练样本 或者 减少样本量过少带来的影响？

（3）为了提高线上效果，请问如何做更好的线下算法测试？

> （1）作为算法同学，请问你想要知道哪些更加详细的业务信息？
> 首先要知道Logo的样式，颜色，材质，大小等外观信息是否会变化。
> 然后想要知道logo应用的场景，是否会存在遮挡，空间角度上的旋转，在图像上的映射不足。
> 然后想要知道logo图片的数据是否充足？
> 等。
> （2）实际情况下我们能够收集到的带logo图片数据非常少，请问有哪些处理方式可以增加训练样本或者减少样本量过少带来的影响？
> 增加训练样本：
> 数据增广： 如果颜色、材质等会发生变化，则尝试改变现有数据的颜色和材质，光照等。如果实际检测情况中有旋转，则可以增加旋转。如果实际情况中存在遮挡的情况，也可以进行裁剪。还可以进行平移等操作。
> 减少样本量过少带来的影响：
> 增加负例，但是要调节权重。（暂时不是很清楚）
> （3）为了提高线上效果，请问如何做更好的线下算法测试？
> 来自百度。
> 一般项目有调研阶段，主要做数据分析和算法线下小规模测试。
>
> 算法测试：
>
> 模型评估：
> 泛化能力,泛化误差，
> 性能度量（Performance Measure）
> 1.Accuracy
> 2.精确率（Precision针对某一类）,召回率（Recall）,F1值，ROC与AUC   -- 分类算法评价指标
> 3.MSE（均方误差）,RMSE（均方根误差）,MAE（平均绝对误差）,R-Squared（拟合度）  ---回归算法评价指标
>
> 算法鲁棒性：
> 在异常状况下的效果。
> 测试方法就是用尽可能多的异常数据来覆盖进行测试。
>
> 模型安全：
> 攻击方法由：试探性攻击、对抗性攻击两种
> 在试探性攻击中，攻击者的目的通常是通过一定的方法窃取模型，或是通过某种手段恢复一部分训练模型所用的数据来推断用户的某些敏感信息。
> 主要分为 模型窃取 和 训练数据窃取
> 对抗性攻击对数据源进行细微修改，让人感知不到，但模型接受该数据后作出错误的判断。
>
> 响应速度：响应速度是指从数据输入到模型预测输出结果的所需时间。对算法进行时间的评价。
> 测试方法：定义装饰器。

### 模型选择

随着深度学习的不断发展，好用的模型越来越多，聊一聊你对模型选择的看法，包括模型规模和数据规模之间的联系。

### 分类指标

在分类问题中我们往往会提到ROC，AUC，PRC等概念，请问如何借助这些指标或其他测试指标判定一个模型在实际场景中的优劣？

这些指标中，AUC作为一个模型评价指标，主要是二分类模型的评价，指的是曲线下面积（Area under Curve），而这个曲线就是ROC曲线。

> 通常ROC曲线在y=x曲线的上方，若是处于下方，则将模型预测反过来即可。AUC值越大，表示该模型的分类正确率越高，自然模型性能相对好一些。至于ROC曲线怎么绘制，通常模型的输出结果都是以概率形式，输出属于某类别的概率，那么我们需要设定一系列阈值，来将概率转化为类别结果，通过不同的阈值进而计算出多组True Positive rate和False Positive rate结果，记得到ROC曲线。对于PRC，即PR曲线，则是针对于单独一类，也是通过不同的阈值计算出它的精确率Precision和召回率Recall，得到PR曲线，PR曲线越往右上方靠，也可以在一定程度上说明模型对该类的分类效果。但是假如测试集中的正负样本比例，出现不同的变化。我们通过画出不同的ROC曲线和PRC曲线，就能发现ROC曲线可以很好地表征模型性能的好坏，而PRC受这个影响比较大。

```

```